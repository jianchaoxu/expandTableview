{
    "Qustions": [
                 {
                 "NO": 1,
                 "title": "1.Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?",
                 "ans": "\tObject-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。",
                 },
                 {
                 "NO": 2,
                 "title": "2. #import 跟#include 又什么区别，@class呢, #import<> 跟 #import””又什么区别?",
                 "ans": "\t#import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字,使用#import头文件会自动只导入一次，不会重复导入，相当于#include和#pragma once;@class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含;#import<>用来包含系统的头文件，#import””用来包含用户头文件。",
                 },
                 {
                 "NO": 3,
                 "title": "3. 属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?",
                 "ans": "\t1). readwrite 是可读可写特性;需要生成getter方法和setter方法时\n\t2). readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变\n\t3). assign 是赋值特性，setter方法将传入参数赋值给实例变量;仅设置变量时;\n\t4). retain 表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1;\n\t5). copy 表示赋值特性，setter方法将传入对象复制一份;需要完全一份新的变量时。\n\t6).nonatomic 非原子操作，决定编译器生成的setter getter是否是原子操作，atomic表示多线程安全，一般使用nonatomic",
                 },
                 {
                 "NO": 4,
                 "title": "4.写一个setter方法用于完成@property (nonatomic,retain)NSString *name,写一个setter方法用于完成@property(nonatomic，copy)NSString *name",
                 "ans": "\t-?(void)?setName:(NSString*)?str\n\t{\n\t[str?retain];\n\t[name?release];\n\tname?=?str;\n\t}\n\t-?(void)setName:(NSString?*)str\n\t{\n\tid?t?=?[str?copy];\n\t[name?release];\n\tname?=?t;\n\t}",
                 },
                 {
                 "NO": 5,
                 "title": "5.常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int",
                 "ans": "object-c的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。",
                 },
                 {
                 "NO": 6,
                 "title": "6.id 声明的对象有什么特性?",
                 "ans": "\tId 声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象;",
                 },
                 {
                 "NO": 7,
                 "title": "7.Objective-C如何对内存管理的,说说你的看法和解决方法?",
                 "ans": "\tObjective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。\n\t1). (Garbage Collection)自动内存计数：这种方式和java类似，在你的程序的执行过程中。始终有一个高人在背后准确地帮你收拾垃圾，你不用考虑它什么时候开始工作，怎样工作。你只需要明白，我申请了一段内存空间，当我不再使用从而这段内存成为垃圾的时候，我就彻底的把它忘记掉，反正那个高人会帮我收拾垃圾。遗憾的是，那个高人需要消耗一定的资源，在携带设备里面，资源是紧俏商品所以iPhone不支持这个功能。所以“Garbage Collection”不是本入门指南的范围，对“Garbage Collection”内部机制感兴趣的同学可以参考一些其他的资料，不过说老实话“Garbage Collection”不大适合适初学者研究。\n\t解决: 通过alloc – initial方式创建的, 创建后引用计数+1, 此后每retain一次引用计数+1, 那么在程序中做相应次数的release就好了.\n\t2). (Reference Counted)手动内存计数：就是说，从一段内存被申请之后，就存在一个变量用于保存这段内存被使用的次数，我们暂时把它称为计数器，当计数器变为0的时候，那么就是释放这段内存的时候。比如说，当在程序A里面一段内存被成功申请完成之后，那么这个计数器就从0变成1(我们把这个过程叫做alloc)，然后程序B也需要使用这个内存，那么计数器就从1变成了2(我们把这个过程叫做retain)。紧接着程序A不再需要这段内存了，那么程序A就把这个计数器减1(我们把这个过程叫做release);程序B也不再需要这段内存的时候，那么也把计数器减1(这个过程还是release)。当系统(也就是Foundation)发现这个计数器变 成员了0，那么就会调用内存回收程序把这段内存回收(我们把这个过程叫做dealloc)。顺便提一句，如果没有Foundation，那么维护计数器，释放内存等等工作需要你手工来完成。\n\t解决:一般是由类的静态方法创建的, 函数名中不会出现alloc或init字样, 如[NSString string]和[NSArray arrayWithObject:], 创建后引用计数+0, 在函数出栈后释放, 即相当于一个栈上的局部变量. 当然也可以通过retain延长对象的生存期.\n\t3). (NSAutoRealeasePool)内存池：可以通过创建和释放内存池控制内存申请和回收的时机.\n\t解决:是由autorelease加入系统内存池, 内存池是可以嵌套的, 每个内存池都需要有一个创建释放对, 就像main函数中写的一样. 使用也很简单, 比如[[[NSString alloc]initialWithFormat:@”Hey you!”] autorelease], 即将一个NSString对象加入到最内层的系统内存池, 当我们释放这个内存池时, 其中的对象都会被释放.",
                 },
                 {
                 "NO": 8,
                 "title": "8. 原子(atomic)跟非原子(non-atomic)属性有什么区别?",
                 "ans": "\t1). atomic提供多线程安全。是防止在写未完成的时候被另外一个线程读取，造成数据错误\n\t2). non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值。",
                 },
                 {
                 "NO": 9,
                 "title": "9. 内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?",
                 "ans": "\t谁申请，谁释放\n\t遵循Cocoa Touch的使用原则;\n\t内存管理主要要避免“过早释放”和“内存泄漏”，对于“过早释放”需要注意@property设置特性时，一定要用对特性关键字，对于“内存泄漏”，一定要申请了要负责释放，要细心。\n\t关键字alloc 或new 生成的对象需要手动释放;\n\t设置正确的property属性，对于retain需要在合适的地方释放，",
                 },
                 {
                 "NO": 10,
                 "title": "10. MVC设计模式是什么？ 你还熟悉什么设计模式？",
                 "ans": "\t设计模式：并不是一种新技术，而是一种编码经验，使用比如java中的接口，iphone中的协议，继承关系等基本手段，用比较成熟的逻辑去处理某一种类型的事情，总结为所谓设计模式。面向对象编程中，java已经归纳了23种设计模式。\n\tmvc设计模式 ：模型，视图，控制器，可以将整个应用程序在思想上分成三大块，对应是的数据的存储或处理，前台的显示，业务逻辑的控制。 Iphone本身的设计思想就是遵循mvc设计模式。其不属于23种设计模式范畴。\n\t代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用.比如一个工厂生产了产品，并不想直接卖给用户，而是搞了很多代理商，用户可以直接找代理商买东西，代理商从工厂进货.常见的如QQ的自动回复就属于代理拦截，代理模式在iphone中得到广泛应用.\n\t单例模式：说白了就是一个类不通过alloc方式创建对象，而是用一个静态方法返回这个类的对象。系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为，比如想获得[UIApplication sharedApplication];任何地方调用都可以得到 UIApplication的对象，这个对象是全局唯一的。\n\t观察者模式： 当一个物体发生变化时，会通知所有观察这个物体的观察者让其做出反应。实现起来无非就是把所有观察者的对象给这个物体，当这个物体的发生改变，就会调用遍历所有观察者的对象调用观察者的方法从而达到通知观察者的目的。",
                 },
                 {
                 "NO": 11,
                 "title": "11. 我们说的oc是动态运行时语言是什么意思?",
                 "ans": "\t多态。 主要是将数据类型的确定由编译时，推迟到了运行时。这个问题其实浅涉及到两个概念，运行时和多态。简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类(life)都用有一个相同的方法-eat;那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消息(响应了eat这个选择器)。因此也可以说，运行时机制是多态的基础?~~~",
                 },
                 {
                 "NO": 12,
                 "title": "12. 响应链",
                 "ans": "\t事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播。可以说点事件的分发，传递以及处理。具体可以去看下touch事件这块。因为问的太抽象化了严重怀疑题目出到越后面就越笼统。可以从责任链模式，来讲通过事件响应链处理，其拥有的扩展性",
                 },
                 {
                 "NO": 13,
                 "title": "13.Object-C的内存管理方式及过程？",
                 "ans": "\t1).当你使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当你不再使用该对象时,你要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.\n\t2).当你通过任何其他方法获得一个对象时,则假设该对象的保留计数器值为1,而且已经被设置为自动释放,你不需要执行任何操作来确保该对象被清理.如果你打算在一段时间内拥有该对象,则需要保留它并确保在操作完成时释放它.\n\t3).如果你保留了某个对象,你需要(最终)释放或自动释放该对象.必须保持retain方法和release方法的使用次数相等.",
                 }
                 ]
}